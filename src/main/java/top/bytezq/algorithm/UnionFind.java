package top.bytezq.algorithm;

/**
 * 动态连通性
 * 问题的输入是一列整数对，其中每个整数都表示一个某种类型的对象，一对整数p q可以被理解为“p和q是相连的”。我们假设“相连”是一种等
 * 价关系，这也就意味着它具有：
 * 1. 自反性：p和p是相连的；
 * 2. 对称性：如果p和q是相连的，那么q和p也是相连的；
 * 3. 传递性：如果p和q是相连的且q和r是相连的，那么p和r也是相连的。
 *
 * 等价关系能够将对象分为多个等价类。在这里，当且仅当两个对象相连时它们才属于同一个等价类。我们的目标是编写一个程序来过滤掉序列
 * 中所有无意义的整数对（两个整数均来自于同一个等价类中）。换句话说，当程序从输入中读取了整数对p、q时，如果已知的所有整数对都不
 * 能说明p和q是相连的，那么则将这一对整数写入到输出中。如果已知的数据可以说明p和q是相连的，那么程序应该忽略p q这对整数并继续处
 * 理输入中的下一对整数。
 */
public class UnionFind {

    // 以整数标识（0到N-1）初始化N个触点
    public UnionFind(int N){}

    // 在p和q之间添加一条连接
    void union(int p, int q){}

    // p（0到N-1）所在的分量的标识符
    int find(int p){}

    // 如果p和q是连通的，则返回true
    boolean connected(int p, int q){}

    // 返回分量的数量
    int count(){}
}
